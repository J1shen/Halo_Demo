graph:
  name: tpch_qbench_longchain_sidecar_rules_v1
  description: >
    TPC-H Q1–Q22-aligned workflow with RULE-BASED parameter extraction (no LLM parsing).
    Topology: long-chain pipeline + one sidecar branch that feeds into the merge hub.
    Compared to trident: NOT 3-way fanout; instead staged analysis with different DB query set
    (focus on Q4/Q7/Q8/Q10/Q11/Q16/Q18/Q19/Q21/Q22-style patterns).

  nodes:
    - id: user_input
      type: input
      outputs: [user_query]

    # ===== 1) deterministic param extraction (reuse your config block) =====
    - id: rule_param_extractor
      type: processor
      processor: regex_param_extractor
      config:  # reuse your full config (enums/regex/defaults/normalize)
        defaults:
          year: 1994
          region: "ASIA"
          segment: "BUILDING"
          shipmode: "MAIL"
          shipmode2: "SHIP"
          date: "1995-03-15"
          discount_lo: 0.05
          discount_hi: 0.07
          qty: 24
          size: 15
          type: "BRASS"
          brand: "Brand#13"
          nation: "CANADA"
          nation2: "GERMANY"
      inputs: [user_query]
      outputs: [tpch_params]

    # ===== 2) Stage A: Order backlog / priority (Q4-like) =====
    - id: stage_a_orders_backlog_qwen14b
      type: inference
      engine: vllm
      model: Qwen/Qwen3-14B
      db_queries:
        - name: tpch_q4_order_priority_check
          sql: >
            SELECT
              o.o_orderpriority,
              COUNT(*) AS order_count
            FROM orders o
            WHERE o.o_orderdate >= make_date(:year::int, 1, 1)
              AND o.o_orderdate <  make_date(:year::int, 1, 1) + INTERVAL '3 month'
              AND EXISTS (
                SELECT 1
                FROM lineitem l
                WHERE l.l_orderkey = o.o_orderkey
                  AND l.l_commitdate < l.l_receiptdate
              )
            GROUP BY o.o_orderpriority
            ORDER BY o.o_orderpriority;
          parameters:
            year: "{{ tpch_params.year }}"
          param_types:
            year: int
      system_prompt: |
        Stage A (Backlog/Priority, Q4-like):
        Interpret the order priority distribution and what it implies about backlog risk.
        Output must be compact and numeric-grounded.
        Respond ONLY with: { "stage_a_notes": "string" }
      inputs: [user_query, tpch_params]
      outputs: [stage_a_notes]

    # ===== 3) Stage B: Cross-nation trade flow (Q7/Q8-like) =====
    - id: stage_b_tradeflow_qwen32b
      type: inference
      engine: vllm
      model: Qwen/Qwen3-32B
      db_queries:
        - name: tpch_q7_volume_between_two_nations
          sql: >
            SELECT
              supp_nation.n_name AS supp_nation,
              cust_nation.n_name AS cust_nation,
              EXTRACT(YEAR FROM l.l_shipdate)::int AS l_year,
              SUM(l.l_extendedprice * (1 - l.l_discount)) AS revenue
            FROM supplier s
            JOIN nation supp_nation ON supp_nation.n_nationkey = s.s_nationkey
            JOIN lineitem l ON l.l_suppkey = s.s_suppkey
            JOIN orders o ON o.o_orderkey = l.l_orderkey
            JOIN customer c ON c.c_custkey = o.o_custkey
            JOIN nation cust_nation ON cust_nation.n_nationkey = c.c_nationkey
            WHERE (
                (supp_nation.n_name = :nation AND cust_nation.n_name = :nation2)
             OR (supp_nation.n_name = :nation2 AND cust_nation.n_name = :nation)
            )
              AND l.l_shipdate >= make_date(:year::int, 1, 1)
              AND l.l_shipdate <  make_date(:year::int, 1, 1) + INTERVAL '2 year'
            GROUP BY supp_nation, cust_nation, l_year
            ORDER BY supp_nation, cust_nation, l_year;
          parameters:
            nation: "{{ tpch_params.nation }}"
            nation2: "{{ tpch_params.nation2 }}"
            year: "{{ tpch_params.year }}"
          param_types:
            nation: text
            nation2: text
            year: int
      system_prompt: |
        Stage B (Trade Flow, Q7/Q8-like):
        Use the nation↔nation revenue by year to infer macro trade-flow patterns.
        Respond ONLY with: { "stage_b_notes": "string" }
      inputs: [user_query, tpch_params, stage_a_notes]
      outputs: [stage_b_notes]

    # ===== 4) Stage C: Customer demand concentration (Q10/Q18-like) =====
    - id: stage_c_demand_qwen32b
      type: inference
      engine: vllm
      model: Qwen/Qwen3-32B
      db_queries:
        # Q10-like: top customers by returned items in a window
        - name: tpch_q10_top_customers_returned
          sql: >
            SELECT
              c.c_custkey,
              c.c_name,
              SUM(l.l_extendedprice * (1 - l.l_discount)) AS revenue
            FROM customer c
            JOIN orders o ON o.o_custkey = c.c_custkey
            JOIN lineitem l ON l.l_orderkey = o.o_orderkey
            JOIN nation n ON n.n_nationkey = c.c_nationkey
            WHERE l.l_returnflag = 'R'
              AND o.o_orderdate >= make_date(:year::int, 1, 1)
              AND o.o_orderdate <  make_date(:year::int, 1, 1) + INTERVAL '3 month'
            GROUP BY c.c_custkey, c.c_name
            ORDER BY revenue DESC
            LIMIT 20;
          parameters:
            year: "{{ tpch_params.year }}"
          param_types:
            year: int

        # Q18-like: large orders over threshold (use qty as threshold proxy)
        - name: tpch_q18_large_orders
          sql: >
            SELECT
              o.o_orderkey,
              SUM(l.l_quantity) AS sum_qty
            FROM orders o
            JOIN lineitem l ON l.l_orderkey = o.o_orderkey
            GROUP BY o.o_orderkey
            HAVING SUM(l.l_quantity) > :qty::numeric
            ORDER BY sum_qty DESC
            LIMIT 20;
          parameters:
            qty: "{{ tpch_params.qty }}"
          param_types:
            qty: numeric
      system_prompt: |
        Stage C (Demand, Q10/Q18-like):
        Diagnose demand concentration:
          - which customers dominate returned-item revenue
          - whether there are "large orders" exceeding qty threshold
        Respond ONLY with: { "stage_c_notes": "string" }
      inputs: [user_query, tpch_params, stage_b_notes]
      outputs: [stage_c_notes]

    # ===== 5) Stage D: Product/brand mix diagnostics (Q16/Q19-like) =====
    - id: stage_d_productmix_openai20b
      type: inference
      engine: vllm
      model: openai/gpt-oss-20b
      db_queries:
        # Q16-like: parts by brand/type/size, simple supplier exclusion removed for simplicity
        - name: tpch_q16_parts_brand_type_size
          sql: >
            SELECT
              p.p_brand,
              p.p_type,
              p.p_size,
              COUNT(*) AS part_cnt
            FROM part p
            WHERE p.p_brand = :brand
              AND p.p_type ILIKE '%' || :type || '%'
              AND p.p_size = :size::int
            GROUP BY p.p_brand, p.p_type, p.p_size
            ORDER BY part_cnt DESC;
          parameters:
            brand: "{{ tpch_params.brand }}"
            type: "{{ tpch_params.type }}"
            size: "{{ tpch_params.size }}"
          param_types:
            brand: text
            type: text
            size: int

        # Q19-like: discounted revenue for a brand (approx, using lineitem+part)
        - name: tpch_q19_discounted_revenue_proxy
          sql: >
            SELECT
              SUM(l.l_extendedprice * (1 - l.l_discount)) AS disc_revenue
            FROM lineitem l
            JOIN part p ON p.p_partkey = l.l_partkey
            WHERE p.p_brand = :brand
              AND l.l_discount BETWEEN :discount_lo::numeric AND :discount_hi::numeric
              AND l.l_quantity < :qty::numeric;
          parameters:
            brand: "{{ tpch_params.brand }}"
            discount_lo: "{{ tpch_params.discount_lo }}"
            discount_hi: "{{ tpch_params.discount_hi }}"
            qty: "{{ tpch_params.qty }}"
          param_types:
            brand: text
            discount_lo: numeric
            discount_hi: numeric
            qty: numeric
      system_prompt: |
        Stage D (Product Mix, Q16/Q19-like):
        Translate product/brand constraints into concrete mix signals, and relate to demand/returns.
        Respond ONLY with: { "stage_d_notes": "string" }
      inputs: [user_query, tpch_params, stage_c_notes]
      outputs: [stage_d_notes]

    # ===== Sidecar: Supplier/region concentration (Q11/Q22-like) =====
    - id: sidecar_stats_qwen14b
      type: inference
      engine: vllm
      model: Qwen/Qwen3-14B
      db_queries:
        # Q11-like proxy: partsupp value concentration for a region (simplified)
        - name: tpch_q11_partsupp_value_region_proxy
          sql: >
            SELECT
              SUM(ps.ps_supplycost * ps.ps_availqty) AS total_value
            FROM partsupp ps
            JOIN supplier s ON s.s_suppkey = ps.ps_suppkey
            JOIN nation n ON n.n_nationkey = s.s_nationkey
            JOIN region r ON r.r_regionkey = n.n_regionkey
            WHERE r.r_name = :region;
          parameters:
            region: "{{ tpch_params.region }}"
          param_types:
            region: text

        # Q22-like proxy: customer account balance distribution (simplified)
        - name: tpch_q22_customer_balance_region_proxy
          sql: >
            SELECT
              COUNT(*) AS cust_cnt,
              AVG(c.c_acctbal) AS avg_acctbal
            FROM customer c
            JOIN nation n ON n.n_nationkey = c.c_nationkey
            JOIN region r ON r.r_regionkey = n.n_regionkey
            WHERE r.r_name = :region
              AND c.c_acctbal > 0.0;
          parameters:
            region: "{{ tpch_params.region }}"
          param_types:
            region: text
      system_prompt: |
        Sidecar Stats (Q11/Q22-like):
        Provide region-level supply-value and customer-balance signals as context.
        Respond ONLY with: { "sidecar_notes": "string" }
      inputs: [user_query, tpch_params]
      outputs: [sidecar_notes]

    # ===== Merge hub (0 DB): combine chain + sidecar =====
    - id: hub_merge_qwen32b
      type: inference
      engine: vllm
      model: Qwen/Qwen3-32B
      system_prompt: |
        Merge Hub:
        Combine Stage A/B/C/D notes with sidecar_notes into one coherent report.
        Goals:
          1) Explain the likely "business story" implied by the metrics.
          2) Identify which dimension (year/region/nation/segment/brand/type/discount/qty) is most sensitive.
          3) Provide 3 actionable follow-up query suggestions from Q1–Q22 (by number) and why.
        Respond ONLY with: { "hub_full_context": "string" }
      inputs:
        - user_query
        - tpch_params
        - stage_a_notes
        - stage_b_notes
        - stage_c_notes
        - stage_d_notes
        - sidecar_notes
      outputs: [hub_full_context]

    # ===== Final (1 DB): fixed verify different from your Q15-only baseline =====
    - id: tpch_final_answer
      type: inference
      engine: vllm
      model: openai/gpt-oss-20b
      db_queries:
        # Use a different verify anchor: Q21-like late shipments (simplified)
        - name: tpch_q21_late_shipments_proxy
          sql: >
            SELECT COUNT(*) AS late_line_cnt
            FROM lineitem l
            WHERE l.l_receiptdate > l.l_commitdate
              AND l.l_shipdate >= make_date(:year::int, 1, 1)
              AND l.l_shipdate <  make_date(:year::int, 1, 1) + INTERVAL '1 year';
          parameters:
            year: "{{ tpch_params.year }}"
          param_types:
            year: int
      system_prompt: |
        Final:
        Produce final_answer grounded in hub_full_context and the late shipment proxy result.
        Keep it concise but data-backed. Respond ONLY with: { "final_answer": "string" }
      inputs: [user_query, tpch_params, hub_full_context]
      outputs: [final_answer]

  edges:
    - from: user_input
      to: rule_param_extractor
      mapping: { user_query: "{{ user_query }}" }

    # sidecar in parallel
    - from: rule_param_extractor
      to: sidecar_stats_qwen14b
      mapping: { user_query: "{{ user_query }}", tpch_params: "{{ tpch_params }}" }

    # long chain
    - from: rule_param_extractor
      to: stage_a_orders_backlog_qwen14b
      mapping: { user_query: "{{ user_query }}", tpch_params: "{{ tpch_params }}" }

    - from: stage_a_orders_backlog_qwen14b
      to: stage_b_tradeflow_qwen32b
      mapping:
        user_query: "{{ user_query }}"
        tpch_params: "{{ tpch_params }}"
        stage_a_notes: "{{ stage_a_notes }}"

    - from: stage_b_tradeflow_qwen32b
      to: stage_c_demand_qwen32b
      mapping:
        user_query: "{{ user_query }}"
        tpch_params: "{{ tpch_params }}"
        stage_b_notes: "{{ stage_b_notes }}"

    - from: stage_c_demand_qwen32b
      to: stage_d_productmix_openai20b
      mapping:
        user_query: "{{ user_query }}"
        tpch_params: "{{ tpch_params }}"
        stage_c_notes: "{{ stage_c_notes }}"

    # merge
    - from: stage_d_productmix_openai20b
      to: hub_merge_qwen32b
      mapping:
        user_query: "{{ user_query }}"
        tpch_params: "{{ tpch_params }}"
        stage_a_notes: "{{ stage_a_notes }}"
        stage_b_notes: "{{ stage_b_notes }}"
        stage_c_notes: "{{ stage_c_notes }}"
        stage_d_notes: "{{ stage_d_notes }}"

    - from: sidecar_stats_qwen14b
      to: hub_merge_qwen32b
      mapping:
        user_query: "{{ user_query }}"
        tpch_params: "{{ tpch_params }}"
        sidecar_notes: "{{ sidecar_notes }}"

    - from: hub_merge_qwen32b
      to: tpch_final_answer
      mapping:
        user_query: "{{ user_query }}"
        tpch_params: "{{ tpch_params }}"
        hub_full_context: "{{ hub_full_context }}"
